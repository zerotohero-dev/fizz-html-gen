<document>
## Valid Parentheses

Given a string s containing just the characters
‚Äú(‚Äù, ‚Äú)‚Äù, ‚Äú{‚Äù, ‚Äú}‚Äù, ‚Äú[‚Äù and ‚Äú]‚Äù, determine if the input string is valid.

An input string is valid if:

* Open brackets are closed by the same type of brackets.
* Open brackets are closed in the correct order.

Here are some sample inputs and outputs:

```text
Input: s = "()"
Output: true
```

```text
Input: s = "()[]{}"
Output: true
```

```text
Input: s = "(]"
Output: false
```

## Solution

* [Using a Stack](./impl.go.html)

## Helpers

* [Driver Function](./main.go.html)

## Further Discussion

[**Stack**](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)) is an excellent data structure for this problem.
Let‚Äôs elaborate why.

One way to think about how to solve this problem is to traverse the input string
one character at a time; put the character you see to the stack, then proceed
to the next character; if the next character is a closing parenthesis that
matches the one you have on the stack, pop the item from the stack.

Let‚Äôs try to visualize this to see why that makes sense.

> **üíÅ Have Your Pen and Paper Ready**
>
> As always, it‚Äôs better to do this yourself using a pen and paper, or a
> whiteboard.
>
> Jotting things down and visualizing them yourself will help you
> understand things **your way**: Which is (*if you ask me*) is the **only**
> way for something to make sense to you.

To get started, let‚Äôs look at the expression below:

```text
{ [ [ ] { } ] } ( ) ( )
```

What if you scanned the expression from left to right, and whenever you
encountered a matching closing parenthesis, you removed the opening/closing
parentheses pair from the expression? `‚Äî [1]`

Notice that parentheses close in reverse order (for, e.g., `{[( ‚Ä¶ )]}`)
Observe that **the last parenthesis that opens closes first**: LIFO!

So, intuitively, using a stack should work because stacks are LIFO data
structures too.

Here‚Äôs how the algorithm [1] would have proceeded with the above input
expression (*`*`‚Äôs show matching parentheses*)

```text
{ [ [ ] { } ] } ( ) ( )
{ [ * * { } ] } ( ) ( )
{ [     * * ] } ( ) ( )
{ *         * } ( ) ( )
*             * ( ) ( )
                * * ( )
                    * *
```

So, where does the stack come in all these? Let‚Äôs see.

Any opening parenthesis we encounter during our left-to-right scan can be
marked for *‚Äúlater processing‚Äù* and put onto a stack. Stack is a perfect data
structure because those *‚Äúmarked‚Äù* parentheses will be processed in reverse
order (*the last one that opens has to close first*).

When you see a closing parenthesis that matches what‚Äôs on top of the stack
during the single-pass scan, you can pop the stack because you have a
matching pair.

Here‚Äôs how the above diagram would look like when we include the stack and
add a few extra markers to clarify what the algorithm does at each step:

```text
( `^` shows where the pointer is at        )
( `*` marks a matching opening parenthesis )

 # Ô∏ô Expression               Ô∏ô Stack Ô∏ô Comments
·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å
 1.Ô∏ô { [ [ ] { } ] } ( ) ( )  Ô∏ô { [ [ Ô∏ô Add until you see a closing paren.
   Ô∏ô     ^                    Ô∏ô       Ô∏ô
·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å
 2.Ô∏ô { [ [ ] { } ] } ( ) ( )  Ô∏ô { [   Ô∏ô Match found, pop stack.
   Ô∏ô     * ^                  Ô∏ô       Ô∏ô
·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å
 3.Ô∏ô { [     { } ] } ( ) ( )  Ô∏ô { [ { Ô∏ô Add until you see a closing paren.
   Ô∏ô         ^                Ô∏ô       Ô∏ô
·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å
 4.Ô∏ô { [     { } ] } ( ) ( )  Ô∏ô { [   Ô∏ô Match found, pop stack.
   Ô∏ô         * ^              Ô∏ô       Ô∏ô
·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å
 5.Ô∏ô { [         ] } ( ) ( )  Ô∏ô {     Ô∏ô Another closing paren, pop stack.
   Ô∏ô   *         ^            Ô∏ô       Ô∏ô
·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å
 6.Ô∏ô {             } ( ) ( )  Ô∏ô #     Ô∏ô Another closing paren, pop again.
   Ô∏ô *             ^          Ô∏ô       Ô∏ô
·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å
 7.Ô∏ô                 ( ) ( )  Ô∏ô (     Ô∏ô Add until you see a closing paren.
   Ô∏ô                 ^        Ô∏ô       Ô∏ô
·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å
 8.Ô∏ô                 ( ) ( )  Ô∏ô #     Ô∏ô Match found, pop stack.
   Ô∏ô                 * ^      Ô∏ô       Ô∏ô
·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å
 9.Ô∏ô                     ( )  Ô∏ô (     Ô∏ô Add until you see a closing paren.
   Ô∏ô                     ^    Ô∏ô       Ô∏ô
·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å
10.Ô∏ô                     ( )  Ô∏ô #     Ô∏ô Match found, pop stack.
   Ô∏ô                     * ^  Ô∏ô       Ô∏ô
·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å·†Å
```

When you reach the end of the string, if your stack is empty, then it means
that every closing parenthesis has a matching opening parenthesis, and thus
your expression is valid.

----
</document>

